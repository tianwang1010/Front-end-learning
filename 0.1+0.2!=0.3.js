// 0.1 + 0.2 != 0.3

// 10进制转化成2进制 
// 整数：采用【除2取余，逆序排列】
// 小数：采用【乘2取整，顺序排列】

console.log(parseInt('101',2))

// 整数位 当前位的值 * 2 ^(n-1) 101
// 5 = 1*2^0 + 0*2^1 + 1*2^2

// 小数位 当前的不停的乘2取整

/**
 * 0.1 转化2进制 0.0001100110011.... 
 * 0.1 * 2 = 0.2 无整数
 * 0.2 * 2 = 0.4 无整数
 * 0.4 * 2 = 0.8 无整数
 * 0.8 * 2 = 1.6 余0.6
 * 0.6 * 2 = 1.2 余0.2
 *  
 * 
 * 
 */
console.log(0.1.toString(2)) // 双精度浮点数 向上取整
console.log(0.2.toString(2))

// 0.1 0.0001100110011001100110011001100110011001100110011001101
// 0.2 0.001100110011001100110011001100110011001100110011001101 

// 0.1+0.2 不等于 0.3 ，因为在 0.1+0.2 的计算过程中发生了两次精度丢失。第一次是在 0.1 和 0.2 转成双精度二进制浮点数时，由于二进制浮点数的小数位只能存储52位，导致小数点后第53位的数要进行为1则进1为0则舍去的操作，从而造成一次精度丢失。第二次在 0.1 和 0.2 转成二进制浮点数后，二进制浮点数相加的过程中，小数位相加导致小数位多出了一位，又要让第53位的数进行为1则进1为0则舍去的操作，又造成一次精度丢失。最终导致 0.1+0.2 不等于0.3 。